package andrew

import (
	"io/fs"
	"net/http"
)

// ListenAndServe creates a server in the contentRoot, listening at the address, with links on autogenerated
// pages to the baseUrl.
// contentRoot - an fs.FS at some location, whether that's a virtual fs.FS such as an fs.Testfs or an
//
//	fs.FS at a location on your file system such as os.DirFS.
//
// contentRoot - an initialised fs.FS. Some implementation details sometimes differ amongst different fs.FS;
// Andrew internally uses an os.DirFS and tests with an fstest.MapFS, so those two have some code examples herein.
// address - an ip:port combination. The AndrewServer will bind an http server here.
// baseUrl - the hostname that you are hosting from.
// certInfo - certificate info type. If the members are empty, Andrew serves http.
func ListenAndServe(contentRoot fs.FS, address string, hostname string, certInfo *CertInfo, rssInfo *RssInfo) error {
	andrewServer := NewServer(contentRoot, address, hostname, *rssInfo)

	mux := http.NewServeMux()
	mux.HandleFunc("/", andrewServer.Serve)
	mux.HandleFunc("/sitemap.xml", andrewServer.ServeSiteMap)
	mux.HandleFunc("/rss.xml", andrewServer.ServeRssFeed)

	server := http.Server{
		Handler: mux,
		Addr:    andrewServer.Address,
	}

	if certInfo != nil && certInfo.CertPath != "" && certInfo.PrivateKeyPath != "" {
		// Use HTTPS with the provided certificate and key
		err := server.ListenAndServeTLS(certInfo.CertPath, certInfo.PrivateKeyPath)
		return err
	}

	// Fallback to HTTP if no certificate is provided
	err := server.ListenAndServe()
	return err
}
